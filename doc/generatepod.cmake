# SPDX-License-Identifier: Unlicense

if (NOT DEFINED INPUTFILEPATH)
    message(FATAL_ERROR "Please define INPUTFILEPATH.")
endif()

# N.B. DO EDIT FOLLOWING ITEMS WHEN OpenSSL UPDATES!

set(HEADER_WARN "
WARNING: do not edit!
Generated by generatepod.cmake from ${INPUTFILEPATH}
"
)

set(OPENSSL_SAFE_DO_NOT_EDIT_HEADERS "
=begin comment
${HEADER_WARN}
=end comment"
)

set(OPENSSL_SAFE_OPT_V_SYNOPSIS "[B<-allow_proxy_certs>]
[B<-attime> I<timestamp>]
[B<-no_check_time>]
[B<-check_ss_sig>]
[B<-crl_check>]
[B<-crl_check_all>]
[B<-explicit_policy>]
[B<-extended_crl>]
[B<-ignore_critical>]
[B<-inhibit_any>]
[B<-inhibit_map>]
[B<-partial_chain>]
[B<-policy> I<arg>]
[B<-policy_check>]
[B<-policy_print>]
[B<-purpose> I<purpose>]
[B<-suiteB_128>]
[B<-suiteB_128_only>]
[B<-suiteB_192>]
[B<-trusted_first>]
[B<-no_alt_chains>]
[B<-use_deltas>]
[B<-auth_level> I<num>]
[B<-verify_depth> I<num>]
[B<-verify_email> I<email>]
[B<-verify_hostname> I<hostname>]
[B<-verify_ip> I<ip>]
[B<-verify_name> I<name>]
[B<-x509_strict>]
[B<-issuer_checks>]")

set(OPENSSL_SAFE_OPT_V_ITEM "=item B<-allow_proxy_certs>, B<-attime>, B<-no_check_time>,
B<-check_ss_sig>, B<-crl_check>, B<-crl_check_all>,
B<-explicit_policy>, B<-extended_crl>, B<-ignore_critical>, B<-inhibit_any>,
B<-inhibit_map>, B<-no_alt_chains>, B<-partial_chain>, B<-policy>,
B<-policy_check>, B<-policy_print>, B<-purpose>, B<-suiteB_128>,
B<-suiteB_128_only>, B<-suiteB_192>, B<-trusted_first>, B<-use_deltas>,
B<-auth_level>, B<-verify_depth>, B<-verify_email>, B<-verify_hostname>,
B<-verify_ip>, B<-verify_name>, B<-x509_strict> B<-issuer_checks>

Set various options of certificate chain verification.
See L<openssl-verification-options(1)/Verification Options> for details.")

set(OPENSSL_SAFE_OPT_X_SYNOPSIS "[B<-xkey> I<infile>]
[B<-xcert> I<file>]
[B<-xchain> I<file>]
[B<-xchain_build> I<file>]
[B<-xcertform> B<DER>|B<PEM>]>
[B<-xkeyform> B<DER>|B<PEM>]>")

set(OPENSSL_SAFE_OPT_X_ITEM "=item B<-xkey> I<infile>, B<-xcert> I<file>, B<-xchain> I<file>,
B<-xchain_build> I<file>, B<-xcertform> B<DER>|B<PEM>,
B<-xkeyform> B<DER>|B<PEM>

Set extended certificate verification options.
See L<openssl-verification-options(1)/Extended Verification Options> for details.
")

set(OPENSSL_SAFE_OPT_NAME_SYNOPSIS "[B<-nameopt> I<option>]")

set(OPENSSL_SAFE_OPT_NAME_ITEM "=item B<-nameopt> I<option>

This specifies how the subject or issuer names are displayed.
See L<openssl-namedisplay-options(1)> for details.")

set(OPENSSL_SAFE_OPT_R_SYNOPSIS "[B<-rand> I<files>]
[B<-writerand> I<file>]")

set(OPENSSL_SAFE_OPT_R_ITEM "=item B<-rand> I<files>, B<-writerand> I<file>

See L<openssl(1)/Random State Options> for details.")

set(OPENSSL_SAFE_OPT_PROVIDER_SYNOPSIS "[B<-provider> I<name>]
[B<-provider-path> I<path>]
[B<-propquery> I<propq>]")

set(OPENSSL_SAFE_OPT_PROVIDER_ITEM "=item B<-provider> I<name>

=item B<-provider-path> I<path>

=item B<-propquery> I<propq>

See L<openssl(1)/Provider Options>, L<provider(7)>, and L<property(7)>.")

set(OPENSSL_SAFE_OPT_CONFIG_SYNOPSIS "[B<-config> I<configfile>]")

set(OPENSSL_SAFE_OPT_CONFIG_ITEM "=item B<-config> I<configfile>

See L<openssl(1)/Configuration Option>.")

set(OPENSSL_SAFE_OPT_ENGINE_SYNOPSIS "")
set(OPENSSL_SAFE_OPT_ENGINE_ITEM "")

# The quoted string will directly go into final documentation so it is intentional that there is no indent here
if (OPENSSL_DEPRECATED_3_0)
set(OPENSSL_SAFE_OPT_ENGINE_SYNOPSIS "[B<-engine> I<id>]
")
set(OPENSSL_SAFE_OPT_ENGINE_ITEM "=item B<-engine> I<id>

See L<openssl(1)/Engine Options>.
This option is deprecated.")
endif()

set(OPENSSL_SAFE_OPT_TRUST_SYNOPSIS "[B<-CAfile> I<file>]
[B<-no-CAfile>]
[B<-CApath> I<dir>]
[B<-no-CApath>]
[B<-CAstore> I<uri>]
[B<-no-CAstore>]")

set(OPENSSL_SAFE_OPT_TRUST_ITEM "=item B<-CAfile> I<file>, B<-no-CAfile>, B<-CApath> I<dir>, B<-no-CApath>,
B<-CAstore> I<uri>, B<-no-CAstore>

See L<openssl-verification-options(1)/Trusted Certificate Options> for details.")

set(OPENSSL_SAFE_OPT_VERSIONTLS_SYNOPSIS "[B<-no_ssl3>]
[B<-no_tls1>]
[B<-no_tls1_1>]
[B<-no_tls1_2>]
[B<-no_tls1_3>]
[B<-ssl3>]
[B<-tls1>]
[B<-tls1_1>]
[B<-tls1_2>]
[B<-tls1_3>]")

set(OPENSSL_SAFE_OPT_VERSIONTLS_ITEM "=item B<-no_ssl3>, B<-no_tls1>, B<-no_tls1_1>, B<-no_tls1_2>, B<-no_tls1_3>,
B<-ssl3>, B<-tls1>, B<-tls1_1>, B<-tls1_2>, B<-tls1_3>

See L<openssl(1)/TLS Version Options>.")

set(OPENSSL_SAFE_OPT_VERSION_SYNOPSIS "${OPENSSL_SAFE_OPT_VERSIONTLS_SYNOPSIS}
[B<-dtls>]
[B<-dtls1>]
[B<-dtls1_2>]")

set(OPENSSL_SAFE_OPT_VERSION_ITEM "${OPENSSL_SAFE_OPT_VERSIONTLS_ITEM}

=item B<-dtls>, B<-dtls1>, B<-dtls1_2>

These specify the use of DTLS instead of TLS.
See L<openssl(1)/TLS Version Options>.")

set(OPENSSL_SAFE_OPT_S_SYNOPSIS "[B<-bugs>]
[B<-no_comp>]
[B<-comp>]
[B<-no_ticket>]
[B<-serverpref>]
[B<-client_renegotiation>]
[B<-legacy_renegotiation>]
[B<-no_renegotiation>]
[B<-no_resumption_on_reneg>]
[B<-legacy_server_connect>]
[B<-no_legacy_server_connect>]
[B<-no_etm>]
[B<-allow_no_dhe_kex>]
[B<-prioritize_chacha>]
[B<-strict>]
[B<-sigalgs> I<algs>]
[B<-client_sigalgs> I<algs>]
[B<-groups> I<groups>]
[B<-curves> I<curves>]
[B<-named_curve> I<curve>]
[B<-cipher> I<ciphers>]
[B<-ciphersuites> I<1.3ciphers>]
[B<-min_protocol> I<minprot>]
[B<-max_protocol> I<maxprot>]
[B<-record_padding> I<padding>]
[B<-debug_broken_protocol>]
[B<-no_middlebox>]")

set(OPENSSL_SAFE_OPT_S_ITEM "=item B<-bugs>, B<-comp>, B<-no_comp>, B<-no_ticket>, B<-serverpref>,
B<-client_renegotiation>,
B<-legacy_renegotiation>, B<-no_renegotiation>,
B<-no_resumption_on_reneg>,
B<-legacy_server_connect>, B<-no_legacy_server_connect>, B<-no_etm>
B<-allow_no_dhe_kex>, B<-prioritize_chacha>, B<-strict>, B<-sigalgs>
I<algs>, B<-client_sigalgs> I<algs>, B<-groups> I<groups>, B<-curves>
I<curves>, B<-named_curve> I<curve>, B<-cipher> I<ciphers>, B<-ciphersuites>
I<1.3ciphers>, B<-min_protocol> I<minprot>, B<-max_protocol> I<maxprot>,
B<-record_padding> I<padding>, B<-debug_broken_protocol>, B<-no_middlebox>

See L<SSL_CONF_cmd(3)/SUPPORTED COMMAND LINE COMMANDS> for details.")

# This is my original thought
# file(STRINGS ${CMAKE_ARGV${START_ARGN}} FILECONTENTS)
# but it fails to parse the file with backslash appears just before end-of-line, it removes the end-of-line completely

# start of a HUGE workaround about CMake `file(STRINGS)` kills backslash before end-of-line with end-of-line
# the backslash - end-of-line combination is what we should preserve!

# warning: following workaround does not support CR-only EOL.

# Read the whole file as hexadecimal
file(READ ${INPUTFILEPATH} FILECONTENTSHEX HEX)

# Searching for "\n" (0x0a) byte by byte for line breaks
#
# I didn't found a string split function in current CMake so implement following on our own.
#
# Normally one byte is two hexadecimal number, so the place of "0a" should always be an even number.
# Place of "0a" being an even number is guaranteed for pure-ASCII since ASCII only use 01~7f where the higher bit is always less than 8. Nothing like "b0a1" exists.
# This case is the lucky case.
#
# But things will go wrong if multibyte character is playing a part, resulting something like "b0a1" exists in the HEX, causing the result is an odd number.
# This is the unlucky case where we must find the next "0a" starts on end of this "0a" and is an odd number, and concatenate the strings altogether for this line.
# Temporarily treat this as an error (implemention is complex). It seems like no multibyte character is in the header file of OpenSSL.
#
# Also we remove trailing CR since some OSes (especially Windows) use CRLF EOL for text files
# This is necessary since trailing CR will be used as escape character in logic below this part

set(FILECONTENTS)
set(FILEFOUND)
string(FIND ${FILECONTENTSHEX} "0a" FILEFOUND)
while (NOT FILEFOUND EQUAL -1)
    set(SINGLELINE)
    math(EXPR FILEFOUNDMOD2 "${FILEFOUND} % 2")
    if (FILEFOUNDMOD2 EQUAL 0)
        # the lucky case
        # kill "\r"
        set(SUBSTRINGEND "${FILEFOUND}")
        if (NOT FILEFOUND EQUAL 0)
            math(EXPR FILEFOUNDMINUS2 "${FILEFOUND} - 2")
            string(SUBSTRING "${FILECONTENTSHEX}" "${FILEFOUNDMINUS2}" 2 SINGLELINELAST2)
            if (SINGLELINELAST2 STREQUAL "0d")
                set(SUBSTRINGEND "${FILEFOUNDMINUS2}")
            endif()
        endif()
        string(SUBSTRING "${FILECONTENTSHEX}" 0 "${SUBSTRINGEND}" SINGLELINE)
        list(APPEND FILECONTENTS "${SINGLELINE}")
        math(EXPR FILEFOUNDPLUS2 "${FILEFOUND} + 2")
        string(SUBSTRING "${FILECONTENTSHEX}" "${FILEFOUNDPLUS2}" -1 REMAINDER)
        set(FILECONTENTSHEX "${REMAINDER}")
    else()
        # TODO: the unlucky case
        message(FATAL_ERROR "not implemented for now")
    endif()
    string(FIND "${FILECONTENTSHEX}" "0a" FILEFOUND)
endwhile()
# also deal with file without EOL on EOF
string(LENGTH "${FILECONTENTSHEX}" FILEFOUND)
if (NOT FILEFOUND EQUAL 0)
    set(SUBSTRINGEND "${FILEFOUND}")
    math(EXPR FILEFOUNDMINUS2 "${FILEFOUND} - 2")
    string(SUBSTRING "${FILECONTENTSHEX}" "${FILEFOUNDMINUS2}" 2 SINGLELINELAST2)
    if (SINGLELINELAST2 STREQUAL "0d")
        set(SUBSTRINGEND "${FILEFOUNDMINUS2}")
    endif()
    string(SUBSTRING "${FILECONTENTSHEX}" 0 "${SUBSTRINGEND}" SINGLELINE)
    list(APPEND FILECONTENTS "${SINGLELINE}")
endif()

# Convert back hexadecimal ASCII to original string, but...
# string(ASCII) receives decimal parameter. If the number is not converted the result is a wrong.
# e.g. "e" becomes "A" without conversion. ASCII of "e" is 65 in hexadecimal, which is "A" in decimal
#
# After the string is converted to original string we can list them up, but...
# The original header file may contain backslash before any arbitrary end-of-line, where the backslash is placed in end-of-string by above logic.
# list(JOIN) joins the end-of-string backslash and CMake list separator ";" WHICH MAKES THE LIST SEPARATOR ESCAPED!!!
# To workaround this, we should escape the end-of-string backslash. Since we removed end-of-string CR in above logic we can use CR as escape character for end-of-string backslash.

set(FILECONTENTSASCII)
foreach (I IN LISTS FILECONTENTS)
    set(I_SPLITTED)
    # Convert the hexadecimal I to decimal and make a list for it, to satisfy string(ASCII)
    string(LENGTH "${I}" I_LENGTH)
    set(I_SUBSTRING_REMAINDER "${I}")
    while(NOT I_LENGTH EQUAL 0)
        string(SUBSTRING "${I_SUBSTRING_REMAINDER}" 0 2 I_SUBSTRING_2)
        math(EXPR I_SUBSTRING_2_DEC "0x${I_SUBSTRING_2}" OUTPUT_FORMAT DECIMAL)
        list(APPEND I_SPLITTED "${I_SUBSTRING_2_DEC}")
        string(SUBSTRING "${I_SUBSTRING_REMAINDER}" 2 -1 I_SUBSTRING_REMAINDER_2)
        set(I_SUBSTRING_REMAINDER "${I_SUBSTRING_REMAINDER_2}")
        string(LENGTH "${I_SUBSTRING_REMAINDER}" I_LENGTH)
    endwhile()
    set(I_ASCII)
    list(LENGTH I_SPLITTED I_SPLITTED_LEN)
    if (NOT I_SPLITTED_LEN EQUAL 0)
        string(ASCII ${I_SPLITTED} I_ASCII)
    endif()
    # escape end-of-string backslash by replacing it with CR. End-of-string backslash will escape the CMake list separator when used alongwith list(APPEND)
    string(REGEX REPLACE "\\\\$" "\r" I_ASCII_ESCAPED_1 "${I_ASCII}")
    # escape ";", satisify CMake list
    string(REPLACE ";" "\;" I_ASCII_ESCAPED_2 "${I_ASCII_ESCAPED_1}")
    list(APPEND FILECONTENTSASCII "${I_ASCII_ESCAPED_2}")
endforeach()

# Here is the middle of the workaround - the file is loaded as FILECONTENTSASCII with end-of-string backslash replaced by CR

function(out_var_func current_func out_var)
    if (current_func MATCHES ".*OpenSSL::safe::opt_v_synopsis.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_V_SYNOPSIS}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_v_item.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_V_ITEM}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_x_synopsis.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_X_SYNOPSIS}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_x_item.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_X_ITEM}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_name_synopsis.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_NAME_SYNOPSIS}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_name_item.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_NAME_ITEM}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_r_synopsis.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_R_SYNOPSIS}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_r_item.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_R_ITEM}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_provider_synopsis.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_PROVIDER_SYNOPSIS}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_provider_item.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_PROVIDER_ITEM}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_config_synopsis.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_CONFIG_SYNOPSIS}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_config_item.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_CONFIG_ITEM}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_engine_synopsis.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_ENGINE_SYNOPSIS}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_engine_item.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_ENGINE_ITEM}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_trust_synopsis.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_TRUST_SYNOPSIS}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_trust_item.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_TRUST_ITEM}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_versiontls_synopsis.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_VERSIONTLS_SYNOPSIS}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_versiontls_item.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_VERSIONTLS_ITEM}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_version_synopsis.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_VERSION_SYNOPSIS}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_version_item.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_VERSION_ITEM}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_s_synopsis.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_S_SYNOPSIS}")
    elseif (current_func MATCHES ".*OpenSSL::safe::opt_s_item.*")
        set("${out_var}" "${OPENSSL_SAFE_OPT_S_ITEM}")
    elseif (current_func MATCHES ".*OpenSSL::safe::output_do_not_edit_headers.*")
        set("${out_var}" "${OPENSSL_SAFE_DO_NOT_EDIT_HEADERS}")
    elseif (current_func MATCHES ".*@autowarntext.*")
        set("${out_var}" "${HEADER_WARN}")
    elseif (current_func MATCHES ".*OPENSSL_CONFIGURED_API.*")
        set("${out_var}" "${OPENSSL_MIN_API}")
    elseif (current_func MATCHES "output_off.+deprecated-3.0")
        if (NOT OPENSSL_DEPRECATED_3_0)
            set("${out_var}" "@GENERATEPOD_CMAKE_OUTPUT_OFF")
        else()
            set("${out_var}" "")
        endif()
    elseif (current_func MATCHES "output_on.+deprecated-3.0")
        if (NOT OPENSSL_DEPRECATED_3_0)
            set("${out_var}" "@GENERATEPOD_CMAKE_OUTPUT_ONN")
        else()
            set("${out_var}" "")
        endif()
    else()
        message(WARNING "no matched out_var for \"${current_func}\"")
        set("${out_var}" "")
    endif()

    set("${out_var}" "${${out_var}}" PARENT_SCOPE)
endfunction()

set(OUTPUT_CONTENTS)

set(FUNCPROCESSING false)
set(OUTPUTON true)
set(FUNCTIONS_LAST_LINE)
foreach (I IN LISTS FILECONTENTSASCII)
    if (NOT FUNCPROCESSING)
        set(OUTPUTLINE "${I}")
    else()
        string(APPEND OUTPUTLINE "${I}")
    endif()

    set(FUNCPROCESSING false)

    string(FIND "${OUTPUTLINE}" "{-" PERLFOUND)
    while (NOT PERLFOUND EQUAL -1)
        string(FIND "${OUTPUTLINE}" "-}" PERLENDFOUND)
        if (PERLENDFOUND EQUAL -1)
            set(FUNCPROCESSING true)
            break()
        endif()

        math(EXPR PERLFOUND_PLUS_2 "${PERLFOUND} + 2")
        math(EXPR PERLFOUND_LENGTH "${PERLENDFOUND} - ${PERLFOUND_PLUS_2}")
        string(SUBSTRING "${OUTPUTLINE}" ${PERLFOUND_PLUS_2} ${PERLFOUND_LENGTH} PERLCURRENTFUNC)
        out_var_func("${PERLCURRENTFUNC}" REPLACEMENT)
        math(EXPR PERLENDFOUND_PLUS_2 "${PERLENDFOUND} + 2")
        string(SUBSTRING "${OUTPUTLINE}" 0 ${PERLFOUND} OUTPUTLINE_HEAD)
        string(SUBSTRING "${OUTPUTLINE}" ${PERLENDFOUND_PLUS_2} -1 OUTPUTLINE_TAIL)
        set(OUTPUTLINE "${OUTPUTLINE_HEAD}${REPLACEMENT}${OUTPUTLINE_TAIL}")
        string(FIND "${OUTPUTLINE}" "{-" PERLFOUND)
    endwhile()

    if (FUNCPROCESSING)
        continue()
    endif()

    set(OUTPUTOFF_POS -1)
    if (NOT OUTPUTON)
        set(OUTPUTOFF_POS 0)
    endif()

    string(FIND "${OUTPUTLINE}" "@GENERATEPOD_CMAKE_OUTPUT_O" OUTPUTCHOICEFOUND)
    while (NOT OUTPUTCHOICEFOUND EQUAL -1)
        string(SUBSTRING "${OUTPUTLINE}" OUTPUTCHOICEFOUND 29 OUTPUTCHOICE)
        if ( ( OUTPUTCHOICE STREQUAL "@GENERATEPOD_CMAKE_OUTPUT_OFF" ) AND ( OUTPUTON ) )
            set(OUTPUTON false)
            set(OUTPUTOFF_POS ${OUTPUTCHOICEFOUND})
        elseif ( ( OUTPUTCHOICE STREQUAL "@GENERATEPOD_CMAKE_OUTPUT_ONN" ) AND ( NOT OUTPUTON ) )
            set(OUTPUTON true)
            math(EXPR OUTPUTOFF_END "OUTPUTCHOICEFOUND + 29")
            string(SUBSTRING "${OUTPUTLINE}" 0 ${OUTPUTOFF_POS} OUTPUTLINE_HEAD)
            string(SUBSTRING "${OUTPUTLINE}" ${OUTPUTOFF_END} -1 OUTPUTLINE_TAIL)
            set(OUTPUTLINE "${OUTPUTLINE_HEAD}${OUTPUTLINE_TAIL}")
        endif()
    endwhile()
    if (NOT OUTPUTON)
        if (OUTPUTOFF_POS EQUAL 0)
            continue()
        endif()
        string(SUBSTRING "${OUTPUTLINE}" 0 ${OUTPUTOFF_POS} OUTPUTLINE_HEAD)
        set(OUTPUTLINE "${OUTPUTLINE_HEAD}")
    endif()

    if (OUTPUTLINE STREQUAL I)
        # Here is the end of workaround - replace end-of-string CR back to backslash if the output is not modified.
        string(REGEX REPLACE "\r$" "\\\\" OUTPUTLINE_UNESCAPE_1 "${OUTPUTLINE}")
        set(OUTPUTLINE "${OUTPUTLINE_UNESCAPE_1}")
    endif()

    string(APPEND OUTPUT_CONTENTS "${OUTPUTLINE}")
    if (OUTPUTON)
        string(APPEND OUTPUT_CONTENTS "\n")
    endif()
endforeach()

if (NOT OUTPUTON)
    message(WARNING "output is off when documentation finishes")
endif()

if (DEFINED OUTPUTFILEPATH)
    get_filename_component(OUT_DIR "${OUTPUTFILEPATH}" DIRECTORY)
    execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory ${OUT_DIR})
    string(REPLACE "\;" ";" OUTPUT_FILE_CONTENTS "${OUTPUT_CONTENTS}")
    file(WRITE ${OUTPUTFILEPATH} "${OUTPUT_FILE_CONTENTS}")
else()
    message(NOTICE "${OUTPUT_CONTENTS}")
endif()


